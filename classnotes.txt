getwd() : get working directory
dir()
to change the working directory : got to FILE--> working directory
source("code.R")  : to load a function

everything is an object
Data types:
	char
	numeric
	integer
	complexed
	logical
	
the most basic : vector --> but a homogeneous container

LIST --> heterogenous vector
empty vector --> vector()

Numbers: 
a numeric object
Inf --> stands for infinity, a special number
NaN --> not a number

Attributes:
	names, dimnames
	dimensions
	class
	length
	other user-defined attributes
	
	attributes() : a function
	
Assignment Operator :  x <- 1
Comments : ##

[1] : this indicates that the variable is a vector	

x <- 1:20

Creating vectors:
	the "c()" function
	the "vector()" function
	
	example  :  x <- c(1,2,3,4)
	
Mixing Objects (implicit coercion)
	y <- c(1.7,"a")
	
	--> in such cases, a simple coercion happens, and all the elements 
	are converted to a same type.
	
Explicit Coercion 
		x <- 0:6
		as.numeric(x);
		
Matrices :
	Nothing but a vector with the attribute DIMENSION
	examples : m <- matrix(1:6 , nrow = 2 , ncol = 3)

	VIMP : they get constructed column wise!!!!!
	
	You can convert a vector to a matrix by just giving it a dim() attribute
	m <- 1:10
	dim(m) <- c(2,5)
	
	
	cbind-ING and rbind-ING
	x <- 1:3
	y <- 4:6
	
	cbind(x,y) 
	rbind(x,y)
	
A LIST!!
	its like a vector of vectors!
	as it holds different data-types, each element is a vector of elements of that data-type
	symbol : [[1]]
	
Factor : 
	used for ordering data!
	catergorizing data
	its like enums!
	its integer based.
	
	example : x <- factor(c("yes" , "yes", "no" ,"no" , "yes"))
				Levels of this factor : yes , no
				
	tables(x) : gives the frequency of all the levels present
	unclass(x) : will give the internal INT values of the different elements
	
	
	Baseline element : the level from which the internal numbering(INT) of the 
	elements start.
	
						:Can be made explicit by using the levels() function
						: levels = c("yes", "no")
		
		
	
	
Missing Values
	is.na()
	is.nan()
	NaN is a na but the reverse is not always a true
	
Data Frames:
	used to store tabular data
	a special type of list.
	every element is a list of the same length
	but every element of the list needn't be of the same type
	attribute : row.names
	function : read.table() or read.csv()
	can be converted/coerce to a matric by data.matrix
	
	
	Example :  x <- data.frame(foo = 1:4 , bar = c(t,f,t,f))

All the variable can have names;
function :  names()


Sub-setting:
	'[' : to get the element with the same class as that of the parent
	'[[' : for getting the elements of a list
	'$' : to get the elements of  a list with names		
	
	
	l <- list(foo = c(1:4) , bar = c(5:9))
	l[["foo"]]
	l$foo
	
	name = "foo"
	l[[name]]  //this implies l$foo 
	
	//to get the multiple elements of the list: for example if the list has three elements
	l(c(1,3)), will return the first and the third element of the list
	
	Nested list : 
	lol <- list(a = list(10,12,123))
	lol[[1]][[2]] ==> 12

	
	Partial matching!!
		when using $ sign , you can give a partial name match too.
		when you use the [[ operator this is not the case, so for that 
		you the following
		x[["a" , exact=FALSE]]
	mat(1,2)
	
Note: 
	when you try to extract a single element from a matric , you do 
	not get a 1 x 1 matrix in return but just a single element.
	In order to turn off this default behaviour, set the DROP=flase
	
	example x[1,2,frop=FLASE]
	
	**ncol function to get the number of columns, similarly nrow(), for the number of rows
	
	Similarly , when you sub-set a single rox/column, you don't get a matrix, but a list in return.
	Again you can use drop=FALSE

Subsetting a list : 
		x <- lisut(foor  =1:4 , bar = 0.6)
		x[1]
		x[[1]]
		x$bar : element associated with the element $bar
		a["bar"] //good thing, you dont need to remember its index
	
		if you want the "indexed name" to be dynamic then you use 2 brackets
		name <- "foo"
		x[[name]]

		incase GOOD <- [TRUE,FLASE...] is a logical list.
		and you say X[good] , this will return a list that is a subset of
		X, but with the elements positioned such that they are TRUE in GOOD

		there is something called...
			complete.cases(),
			which too helps in removing the NA elements from the list
		
Read and write data
	 read.table
	 read.csv
	 readlines
	source //for reading in the R codes into the eexcutable environment
	dget //read R objects
	load //reading binary files


writing:
	write.table
	writeLines
	dump
	dput
	save
	serialize

read.csv is same as read.table except that the delimiter is a comma

please always specify the TYPE of data in the file , and specify the same using colClasses, else R will take a lot of time figuring out what kind of classes its reading and in case of large datasets it will slow down thigs pretty bad

there is an argument called NROWs, which gives R an estimate on the number of rows it will be reading. Helps it in estimating the RAM usage.
Even if you give the wrong number doesnt matter as it will still read all of them.
	

Textual Formats , not very space efficient, but easier to read

**dump same as dput but , dump allows you to dump multiple R objects together

Interface to the outside world
	file, gzfile, bzfile, url 

	
	
LOOPS and Stuff
	for(i in 1:10)
	{
	}
	
	for(i in seq_along(x))
	{
	}
	
	for(letter in x)
	{
	}
	
	
Functions:
	using the function()n directive.
	function is also stored as an R object
	
	f <- funciotn(<args>) { do something}
	
	**functions are considered "first class objects", and so they are like
	normal R objects
	
	Functions with named arguments, and with default values
	
	**function FORMALS(), to get the args of a function
	
	Example :
		f <- function(a,b)
		{
		}
		
	Lazy evaluation:
		An argument is not evaluated, until and unless its not used
	
	
		functions(a,b,...) //generic args!!!

		the function returns what ever the last expression of the function evaluates to
		
		
Scoping Rules : 
	search() , will tell you where all the functions are searched for . Its like the environment inside which R is running